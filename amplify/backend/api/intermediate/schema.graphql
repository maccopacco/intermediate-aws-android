type TestGoal @model {
    id: ID!
    content: String
}

type User @model {
    id: ID!
    googleID: String!
    originalEmail: String!
    banks: [Bank!] @connection(name: "User_Bank")
}

type Bank @model {
    id: ID!
    user: User! @connection(name: "User_Bank")
    plaid_access_token: String!
    institution_id: String!
    institution_name: String
    institution_logo: String
    last_touched_time: AWSDateTime!
    userData: UserData @connection(name: "Bank_UserData")
}

type UserData @model {
    id: ID!
    bank: Bank! @connection(name: "Bank_UserData")
    max_import_batch: Int!
    oldest_pending_date: AWSDate
    accounts: [Account!] @connection(name: "UserData_Account")
    transactions: [Transaction!] @connection(name: "UserData_Transaction")
}

type Account @model {
    id: ID!
    plaidID: String!
    name: String!
    overrideName: String
    userData: UserData! @connection(name: "UserData_Account")
    balances: [Balance!] @connection(name: "Account_Balance")
    #    transactions: [Transaction!] @connection(name: "Account_Transaction")
}

type Balance @model {
    id: ID!
    account: Account! @connection(name: "Account_Balance")
    availableBalance: Float!
    currentBalance: Float!
    time: AWSDateTime!
}

type Transaction @model {
    id: ID!

    # Simple features
    overrideName: String
    memo: String

    #Imports
    importBatch: Int
    importDate: AWSDateTime
    importSource: String

    plaidID: String # Plaids identifier for this transaction
    userData: UserData! @connection(name: "UserData_Transaction")
    account: String!
    #    account: Account @connection(name: "Account_Transaction")

    # From Plaid
    amount:    Float!
    isoCurrencyCode:    String
    unofficialCurrencyCode:    String
    categoryFolder: String
    category: [String]
    categoryId:    String
    date:    AWSDate
    exactTime: AWSDateTime
    location:    Location @connection(name: "Transaction_Location")
    merchantName:    String
    name:    String
    originalDescription:    String
    paymentMeta:    PaymentMeta @connection(name: "Transaction_PaymentMeta")
    pending:    Boolean
    pendingTransactionId:    String
    transactionId:    String
    transactionType:    String
    accountOwner:    String
    authorizedDate:    String
    transactionCode:    String
    paymentChannel:    String
}

type PaymentMeta @model {
    id: ID!
    transaction: Transaction! @connection(name: "Transaction_PaymentMeta")
    byOrderOf: String
    payee: String
    payer: String
    paymentMethod: String
    paymentProcessor: String
    ppdId: String
    reason: String
    referenceNumber: String
}

type Location @model{
    id: ID!
    transaction: Transaction! @connection(name: "Transaction_Location")
    address: String
    city: String
    lat: Float
    lon: Float
    region: String
    storeNumber: String
    postalCode: String
    country: String
}