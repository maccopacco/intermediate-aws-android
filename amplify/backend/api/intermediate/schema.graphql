type TestGoal @model {
    id: ID!
    content: String
}

type User @model {
    id: ID!
    googleID: String!
    originalEmail: String!
    banks: [Bank] @connection(name: "User_Bank")
}

type Bank @model {
    id: ID!
    user: User! @connection(name: "User_Bank")
    plaid_access_token: String!
    institution_id: String!
    institution_name: String
    institution_logo: String
    last_touched_time: String!
    userData: UserData @connection(name: "Bank_Data")
}

type UserData @model {
    id: ID!
    bank: Bank! @connection(name: "Bank_Data")
    transactions: [TransactionWrapper] @connection(name: "Data_Transactions")
    max_import_batch: Int!
    oldest_pending_time: String
}

type TransactionWrapper @model {
    id: ID!
    importBatch: Int
    importDate: String
    importSource: String
    plaidID: String
    userData: UserData! @connection(name: "Data_Transactions")
    transaction: Transaction! @connection(name: "Transaction_Wrapper")
    overrideName: String
    memo: String
}

type Transaction @model {
    id: ID!
    wrapper: TransactionWrapper @connection(name: "Transaction_Wrapper")
    accountId: String
    amount:    Float!
    isoCurrencyCode:    String
    unofficialCurrencyCode:    String
    categoryFolder: String
    category: [String]
    categoryId:    String
    date:    String
    exactTime: String
    location:    Location @connection(name: "Transaction_Location")
    merchantName:    String
    name:    String
    originalDescription:    String
    paymentMeta:    PaymentMeta @connection(name: "Transaction_PaymentMeta")
    pending:    Boolean
    pendingTransactionId:    String
    transactionId:    String
    transactionType:    String
    accountOwner:    String
    authorizedDate:    String
    transactionCode:    String
    paymentChannel:    String
}

type PaymentMeta @model {
    id: ID!
    transaction: Transaction! @connection(name: "Transaction_PaymentMeta")
    byOrderOf: String
    payee: String
    payer: String
    paymentMethod: String
    paymentProcessor: String
    ppdId: String
    reason: String
    referenceNumber: String
}

type Location @model{
    id: ID!
    transaction: Transaction! @connection(name: "Transaction_Location")
    address: String
    city: String
    lat: Float
    lon: Float
    region: String
    storeNumber: String
    postalCode: String
    country: String
}